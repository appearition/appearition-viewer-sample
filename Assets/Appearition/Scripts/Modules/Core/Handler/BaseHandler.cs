// -----------------------------------------------------------------------
// Company:"Appearition Pty Ltd"
// File: BaseHandler.cs
// Copyright (c) 2019. All rights reserved.
// -----------------------------------------------------------------------

#pragma warning disable 0162

using System.Collections.Generic;
using Appearition.API;
using Appearition.Profile;
using UnityEngine;
using System;
using System.Collections;
using System.IO;
using Appearition.Common.ObjectExtensions;
using Appearition.Internal;
using UnityEngine.Networking;

namespace Appearition.Common
{
    /// <summary>
    /// Base API handler.
    /// </summary>
    public abstract class BaseHandler
    {
        #region Api Pooling

        /// <summary>
        /// List containing all the API requests that are either used or ready to be used.
        /// </summary>
        private static readonly List<BaseApi> ApiRequestStack = new List<BaseApi>();

        /// <summary>
        /// Fetches (or creates) an API request sample of the given type. Stores them locally for reusable purpose.
        /// </summary>
        /// <typeparam name="T">The 1st type parameter.</typeparam>
        public static T GetReusableApiRequest<T>() where T : BaseApi, new()
        {
            T output = null;

            //Try to find an API request of the given type in the container
            for (int i = 0; i < ApiRequestStack.Count; i++)
            {
                if (ApiRequestStack[i].GetType() == typeof(T) && !ApiRequestStack[i].IsBeingUsed)
                {
                    output = (T) ApiRequestStack[i];
                    break;
                }
            }

            //If none found, create a new one and store it.
            if (output == null)
            {
                output = new T();
                ApiRequestStack.Add(output);
            }

            return output;
        }

        #endregion

        #region Path Utilities

        /// <summary>
        /// The name of the directory inside the root where all the content from this handler is to be saved.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public static string GetHandlerStoragePath<T>() where T : BaseHandler
        {
            string folderPath = string.Format("{0}/{1}", AppearitionConstants.RootDirectory, typeof(T).Name);
            if (!Directory.Exists(folderPath) && AppearitionConstants.enableApiResponseStorage)
                Directory.CreateDirectory(folderPath);
            return folderPath;
        }

        #region Json-Specific

        /// <summary>
        /// Name of the folder where JSON data will be stored when appropriate.
        /// </summary>
        public const string JSON_FOLDER_NAME = "JSON";

        /// <summary>
        /// Fetches the folder name where the JSON files generated by the given type should be located.
        /// </summary>
        /// <returns>The json folder path.</returns>
        /// <typeparam name="T">Handler class</typeparam>
        protected static string GetHandlerJsonFolderPath<K>() where K : BaseHandler
        {
            string folderPath = string.Format("{0}/{1}", GetHandlerStoragePath<K>(), JSON_FOLDER_NAME);
            if (!Directory.Exists(folderPath) && AppearitionConstants.enableApiResponseStorage)
                Directory.CreateDirectory(folderPath);
            return folderPath;
        }

        /// <summary>
        /// Generates a filename for a json file based on an API type and user profile.
        /// </summary>
        /// <returns></returns>
        public static string GetApiJsonFullPath<T, K>() where T : BaseApi, new() where K : BaseHandler
        {
            return GetApiJsonFullPath<T, K>(AppearitionGate.Instance.CurrentUser);
        }

        /// <summary>
        /// Generates a filename for a json file based on an API type and user profile.
        /// </summary>
        /// <returns>The json file name.</returns>
        /// <param name="user">Related user</param>
        public static string GetApiJsonFullPath<T, K>(UserProfile user) where T : BaseApi, new() where K : BaseHandler
        {
            return GetApiJsonFullPath<T, K>(null, user, user.selectedChannel);
        }

        /// <summary>
        /// Generates a filename for a json file based on an API type and user profile.
        /// </summary>
        /// <param name="api"></param>
        /// <param name="user"></param>
        /// <returns></returns>
        public static string GetApiJsonFullPath<T, K>(T api, UserProfile user) where T : BaseApi, new() where K : BaseHandler
        {
            return GetApiJsonFullPath<T, K>(api, user, user.selectedChannel);
        }

        /// <summary>
        /// Generates a filename for a json file based on an API type and user profile.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="channelId"></param>
        /// <param name="extra"></param>
        /// <returns></returns>
        public static string GetApiJsonFullPath<T, K>(UserProfile user, int channelId, string extra = "") where T : BaseApi, new() where K : BaseHandler
        {
            return GetApiJsonFullPath<T, K>(null, user, channelId, extra);
        }

        /// <summary>
        /// Generates a filename for a json file based on an API type and user profile.
        /// </summary>
        /// <param name="api"></param>
        /// <param name="user"></param>
        /// <param name="channelId"></param>
        /// <param name="extra"></param>
        /// <returns></returns>
        public static string GetApiJsonFullPath<T, K>(T api, UserProfile user, int channelId, string extra = "") where T : BaseApi, new() where K : BaseHandler
        {
            if (api == null)
                api = GetReusableApiRequest<T>();

            return $"{GetHandlerJsonFolderPath<K>()}/{user.selectedTenant}_{typeof(T).Name}_{channelId}_{(string.IsNullOrEmpty(extra) ? "" : extra + "_")}{api.ApiVersion.ToString()}.txt";
        }
        
        public static string GetApiDownloadedBytesFullPath<T,K>(T api, UserProfile user, int channelId, string extra = "") where T : BaseApi, new() where K : BaseHandler
        {
            if (api == null)
                api = GetReusableApiRequest<T>();

            return $"{GetHandlerJsonFolderPath<K>()}/{user.selectedTenant}_{typeof(T).Name}_{channelId}_{(string.IsNullOrEmpty(extra) ? "" : extra + "_")}{api.ApiVersion.ToString()}_bytes";
        }

        #endregion

        #endregion

        #region File saving and loading

        #region Local

        const int ATTEMPT_COUNT_BEFORE_GIVING_UP_IO_PROCESS = 3;
        const float TIME_BETWEEN_EACH_IO_ATTEMPTS = 0.5f;

        #region Get

        /// <summary>
        /// Fetches the content of a local file at a given path.
        /// </summary>
        /// <param name="pathToFile">The full path to the file.</param>
        /// <param name="onComplete">Called once the process has completed. Contains the content of the data of the Media.</param>
        /// <param name="loadTransferStatus"></param>
        protected static IEnumerator GetContentFromFileProcess(string pathToFile, Action<byte[]> onComplete = null, DataTransferStatus loadTransferStatus = null)
        {
            if (!AppearitionConstants.enableLocalFileStorage)
            {
                onComplete?.Invoke(null);
                yield break;
            }
            
            //Empty check
            if (string.IsNullOrEmpty(pathToFile))
            {
                AppearitionLogger.LogError("Empty path provided when trying to get the content of a file.");
                if (onComplete != null)
                    onComplete(null);
                yield break;
            }

            //No file check
            if (!File.Exists(pathToFile))
            {
                AppearitionLogger.LogWarning(string.Format("Tried to load a File at path {0} but no file was found at that location.", pathToFile));
                if (onComplete != null)
                    onComplete(null);
                yield break;
            }

            //Create directory if needed
            if (!Directory.Exists(Path.GetDirectoryName(pathToFile)))
                Directory.CreateDirectory(Path.GetDirectoryName(pathToFile));

            if (Application.platform == RuntimePlatform.Android)
                pathToFile = string.Format("file:///{0}", pathToFile);
            else
                pathToFile = string.Format("file://{0}", pathToFile);


            bool transferStatusCreated = false;
            if (loadTransferStatus == null)
            {
                loadTransferStatus = new DataTransferStatus();
                transferStatusCreated = true;
            }

            string loadTransferItemKey = Guid.NewGuid().ToString();
            loadTransferStatus.AddNewItemProgress(loadTransferItemKey, Path.GetFileName(pathToFile), 0, transferStatusCreated);

            UnityWebRequest loadMediaProcess = UnityWebRequest.Get(pathToFile.Trim());

            loadMediaProcess.SendWebRequest();

            while (!loadMediaProcess.isDone)
            {
                loadTransferStatus.UpdateItemProgress(loadTransferItemKey, loadMediaProcess.downloadProgress);
                yield return null;
            }

            //Regardless of the outcome, set it to complete.
            if (loadTransferStatus.itemProgress[loadTransferItemKey].Progress < 1.0f)
                loadTransferStatus.UpdateItemProgress(loadTransferItemKey, 1.0f);

            byte[] outcome = null;
            if (loadMediaProcess.downloadHandler.data != null && loadMediaProcess.downloadHandler.data.Length > 0)
            {
                //Make an object out of it !
                outcome = loadMediaProcess.downloadHandler.data;
            }
            else
                AppearitionLogger.LogWarning(string.Format("Tried to load data at the path {0} but failed.", pathToFile));

            if (onComplete != null)
                onComplete(outcome);
        }

        #endregion

        #region Save

        /// <summary>
        /// Saves the Media File data to the given path.
        /// </summary>
        /// <param name="data">The content of this File.</param>
        /// <param name="pathToFile">The full path to the file.</param>
        /// <param name="onComplete">Called once the process has completed. Contains whether or not the operation was successful.</param>
        protected static IEnumerator SaveContentToFileProcess(byte[] data, string pathToFile, Action<bool> onComplete = null)
        {
            if (!AppearitionConstants.enableLocalFileStorage)
            { 
                onComplete?.Invoke(true);
                yield break;
            }
            
            //Empty check
            if (string.IsNullOrEmpty(pathToFile))
            {
                AppearitionLogger.LogError("Empty path provided when trying to save the content of a file.");
                if (onComplete != null)
                    onComplete(false);
                yield break;
            }

            //Empty data check
            if (data == null)
            {
                AppearitionLogger.LogWarning(string.Format("Tried to save empty data for a file at path {0}. Aborting process.", pathToFile));
                if (onComplete != null)
                    onComplete(false);
                yield break;
            }

            //Create directory if needed
            if (!Directory.Exists(Path.GetDirectoryName(pathToFile)))
                Directory.CreateDirectory(Path.GetDirectoryName(pathToFile));

            int attempt = 0;
            bool isSuccess = true;

            do
            {
                //Save it!
                try
                {
                    File.WriteAllBytes(pathToFile, data);
                } catch
                {
                    isSuccess = false;
                }

                if (!isSuccess && attempt < ATTEMPT_COUNT_BEFORE_GIVING_UP_IO_PROCESS)
                {
                    attempt++;
                    yield return new WaitForSeconds(TIME_BETWEEN_EACH_IO_ATTEMPTS);
                }
                else
                    break;
            } while (true);

            if (onComplete != null)
                onComplete(true);
        }

        #endregion

        #region Delete

        /// <summary>
        /// Deletes the file at a given path.
        /// </summary>
        /// <param name="pathToFile">Full path to the file.</param>
        /// <param name="onComplete">Called once the process has completed. Contains whether or not the operation was successful.</param>
        protected static IEnumerator DeleteFileProcess(string pathToFile, Action<bool> onComplete = null)
        {
            //Empty check
            if (string.IsNullOrEmpty(pathToFile))
            {
                AppearitionLogger.LogWarning("Empty path provided when trying to delete a file.");
                if (onComplete != null)
                    onComplete(false);
                yield break;
            }

            //No file check
            if (!File.Exists(pathToFile))
            {
                AppearitionLogger.LogWarning(string.Format("Tried delete a file at path {0} but no file was found at that location.", pathToFile));
                if (onComplete != null)
                    onComplete(false);
                yield break;
            }

            //Create directory if needed
            if (!Directory.Exists(Path.GetDirectoryName(pathToFile)))
                Directory.CreateDirectory(Path.GetDirectoryName(pathToFile));

            int attempt = 0;

            while (true)
            {
                bool isSuccess = true;
                try
                {
                    File.Delete(pathToFile);
                } catch
                {
                    //Issue occured when trying to delete. Wait a bit.. Unless file is already gone?
                    if (!File.Exists(pathToFile))
                        break;

                    isSuccess = false;
                }

                if (!isSuccess && attempt < ATTEMPT_COUNT_BEFORE_GIVING_UP_IO_PROCESS)
                {
                    attempt++;
                    yield return new WaitForSeconds(TIME_BETWEEN_EACH_IO_ATTEMPTS);
                }
                else
                    break;
            }

            if (onComplete != null)
                onComplete(true);
        }

        #endregion

        #region Copy

        /// <summary>
        /// Copies the file from a source location to a given destination full path.
        /// </summary>
        /// <param name="pathToSourceFile">Full path to the source file.</param>
        /// <param name="pathToDestinationFile">Full path to the destination file.</param>
        /// <param name="onComplete">Called once the process has completed. Contains whether or not the operation was successful.</param>
        protected static IEnumerator CopyFileToDestinationProcess(string pathToSourceFile, string pathToDestinationFile, Action<bool> onComplete = null)
        {
            //Empty check
            if (string.IsNullOrEmpty(pathToSourceFile) || string.IsNullOrEmpty(pathToDestinationFile))
            {
                AppearitionLogger.LogWarning("Empty source path provided when trying to copy a file.");
                if (onComplete != null)
                    onComplete(false);
                yield break;
            }

            //Create directory if needed
            if (!Directory.Exists(Path.GetDirectoryName(pathToDestinationFile)))
                Directory.CreateDirectory(Path.GetDirectoryName(pathToDestinationFile));

            int attempt = 0;
            bool isSuccess = true;

            while (true)
            {
                //Copy!
                try
                {
                    File.Copy(pathToSourceFile, pathToDestinationFile, true);
                } catch
                {
                    isSuccess = false;
                }

                if (!isSuccess && attempt < ATTEMPT_COUNT_BEFORE_GIVING_UP_IO_PROCESS)
                {
                    attempt++;
                    yield return new WaitForSeconds(TIME_BETWEEN_EACH_IO_ATTEMPTS);
                }
                else
                    break;
            }

            if (onComplete != null)
                onComplete(isSuccess);
        }

        #endregion

        #region Checksum

        /// <summary>
        /// Whether or not the existing file's checksum matches a given checksum.
        /// </summary>
        /// <param name="fullPath">The full path to the file.</param>
        /// <param name="checksum">The checksum of the file's current version as it came down from the EMS.</param>
        /// <returns>Whether or not the existing file's checksum matches a given checksum.</returns>
        public static bool IsThereExistingMediaWithMatchingChecksum(string fullPath, string checksum)
        {
            if (!File.Exists(fullPath))
                return false;

            string existingFileChecksum = GetChecksumFromExistingFile(fullPath);
            if (string.IsNullOrEmpty(existingFileChecksum))
                return false;

            return existingFileChecksum.Equals(checksum, StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Obtains the checksum of a local file.
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        public static string GetChecksumFromExistingFile(string path)
        {
            string checksum = "";
            try
            {
                using (var file = new FileStream(path, FileMode.Open, FileAccess.ReadWrite, FileShare.Read))
                {
                    checksum = file.Checksum();
                }
            } catch (IOException)
            {
                checksum = "";
            }

            return checksum;
        }

        #endregion

        #region Clear Cache

        /// <summary>
        /// Fully deletes the stored content for this container from this device.
        /// </summary>
        /// <param name="onComplete">Called once the process has completed. Contains whether or not the operation was successful.</param>
        public static IEnumerator ClearHandlerCache<T>(Action<bool> onComplete = null) where T : BaseHandler
        {
            string directoryPath = GetHandlerStoragePath<T>();

            int attempt = 0;
            bool isSuccess = true;

            while (true)
            {
                try
                {
                    if (Directory.Exists(directoryPath))
                        Directory.Delete(directoryPath, true);

                    isSuccess = true;
                } catch
                {
                    //Issue occured when trying to delete. Wait a bit.. Unless file is already gone?
                    if (!File.Exists(directoryPath))
                        break;

                    isSuccess = false;
                }

                if (!isSuccess && attempt < ATTEMPT_COUNT_BEFORE_GIVING_UP_IO_PROCESS)
                {
                    attempt++;
                    yield return new WaitForSeconds(TIME_BETWEEN_EACH_IO_ATTEMPTS);
                }
                else
                    break;
            }

            if (onComplete != null)
                onComplete?.Invoke(isSuccess);
        }

        #endregion

        #endregion

        #region Cloud

        /// <summary>
        /// Defines what authentication type will be used for the downloads. By default, the highest authentication should be the one in charge.
        /// </summary>
        protected static AuthenticationOverrideType TokenUsedForDownloads
        {
            get { return AuthenticationOverrideType.ApplicationToken; }
        }

        /// <summary>
        /// Downloads a file from the EMS to a given full path (including file name and extension).
        /// If the file already exists with a matching checksum, will load the local file instead.
        /// </summary>
        /// <param name="url">Full URL where the file is located.</param>
        /// <param name="fileFullPath">The full path to the file that is about to get downloaded.</param>
        /// <param name="checksum">The checksum of the file's current version as it came down from the EMS.</param>
        /// <param name="saveFile">Whether or not the downloaded file should be saved locally.</param>
        /// <param name="onComplete">Called once the process has completed. Contains the data that was downloaded and saved.</param>
        /// <param name="downloadTransferStatus"></param>
        public static IEnumerator DownloadGenericFile(string url, string fileFullPath, string checksum, bool saveFile, Action<byte[]> onComplete,
            DataTransferStatus downloadTransferStatus = null)
        {
            //Wait for internet check, or handle offline.
            while (!AppearitionGate.HasInternetAccessToEms.HasValue)
                yield return null;

            if (!AppearitionGate.HasInternetAccessToEms.Value)
            {
                yield return GetContentFromFileProcess(fileFullPath, onComplete, downloadTransferStatus);
                yield break;
            }

            //Check the versioning using mediaChecksum if the file already exists
            if (!string.IsNullOrEmpty(checksum) && IsThereExistingMediaWithMatchingChecksum(fileFullPath, checksum))
            {
                //Version match, load the existing file.
                yield return GetContentFromFileProcess(fileFullPath, onComplete, downloadTransferStatus);
            }
            else
            {
                //Handle transfer status
                bool transferStatusCreated = false;
                if (downloadTransferStatus == null)
                {
                    downloadTransferStatus = new DataTransferStatus();
                    transferStatusCreated = true;
                }

                //Ensure there is a GUID, since we're using it as a key.
                string itemProgressKey = Guid.NewGuid().ToString();

                //First, get file size.
                long? fileSize = 0;
                yield return GetEmsContentFileSize(url, outcome => fileSize = outcome);

                //Add data transfer entry
                downloadTransferStatus.AddNewItemProgress(itemProgressKey, Path.GetFileName(fileFullPath), fileSize.GetValueOrDefault(), transferStatusCreated);

                //Download the new file.
                Dictionary<string, string> headers = AppearitionGate.Instance.CurrentUser.GetAuthenticationHeaders(TokenUsedForDownloads);

                //Handle case where no token was provided.
                if (!headers.ContainsKey("authentication-token"))
                    headers.Add("authentication-token", AppearitionGate.Instance.CurrentUser.GetHighestLevelAuthenticationToken);

                headers.Add("Content-Type", "application/json");

                UnityWebRequest mediaDownload = UnityWebRequest.Get(url.Trim());
                mediaDownload.certificateHandler = new AppearitionCertificateHandler();

                foreach (var kvp in headers)
                    mediaDownload.SetRequestHeader(kvp.Key, kvp.Value);

                mediaDownload.SendWebRequest();

                while (!mediaDownload.isDone)
                {
                    downloadTransferStatus.UpdateItemProgress(itemProgressKey, mediaDownload.downloadProgress);
                    yield return null;
                }

                //Regardless of the outcome, set it to complete.
                if (downloadTransferStatus.itemProgress[itemProgressKey].Progress < 1.0f)
                    downloadTransferStatus.UpdateItemProgress(itemProgressKey, 1.0f);

                if (string.IsNullOrEmpty(mediaDownload.error) && mediaDownload.downloadHandler.data != null)
                {
                    if (saveFile && Application.platform != RuntimePlatform.WebGLPlayer)
                    {
                        bool isSaveSuccess = false;
                        yield return SaveContentToFileProcess(mediaDownload.downloadHandler.data, fileFullPath,
                            saveSuccess => isSaveSuccess = saveSuccess);

                        if (!isSaveSuccess)
                        {
                            AppearitionLogger.LogError(string.Format("An issue occured when trying to save the file of name {0}.", Path.GetFileName(fileFullPath)));
                            if (onComplete != null)
                                onComplete(null);
                            mediaDownload.Dispose();
                            yield break;
                        }
                    }
                }
                else
                {
                    AppearitionLogger.LogError(string.Format("Issues when trying to download the file {0} from URL {1}. Error: {2}. Token: {3}", Path.GetFileName(fileFullPath), url,
                        mediaDownload.error,
                        headers["authentication-token"]));
                }


                if (onComplete != null)
                    onComplete(mediaDownload.downloadHandler.data);
                mediaDownload.Dispose();
            }
        }

        /// <summary>
        /// Attempts to get the file size for a file on the EMS.
        /// </summary>
        /// <param name="url"></param>
        /// <param name="outcome"></param>
        /// <returns></returns>
        protected static IEnumerator GetEmsContentFileSize(string url, Action<long?> outcome)
        {
            if (outcome == null)
                yield break;

            UnityWebRequest fileSizeCheck = UnityWebRequest.Head(url.Trim());
            yield return fileSizeCheck.SendWebRequest();
            string outcomeSize = fileSizeCheck.GetResponseHeader("Content-Length");

            if (!string.IsNullOrEmpty(outcomeSize))
                outcome(Convert.ToInt64(outcomeSize));
            else
                outcome(default);
        }

        #endregion

        #endregion
    }
}